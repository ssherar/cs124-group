\paragraph{\small{\tab Moving and resizing class rectangles\\*}}

\hspace{-10pt}Moving class rectangles is simple enough. Whenever the mouse is dragged on a ClassRectangle component, the ClassController updates the location of the ClassModel which then notifies its observers. A LocationEdit is created and sent to the compoundEdit residing in the ClassModel. Once dragging is finished, the whole compound edit is sent to the Manager. The ClassRectangle changes its own location in accordance and the Canvas is forced to re-layout. However, we need to think about Relationships as well. This is where the RelationshipEndPoint class comes in. Each RelationshipEndPoint is defined as having a precise position on the border of the class rectangle. When this changes its (x,y) coordinates, the (x,y) coordinates of the RelationshipEndPoints can be updated easily as well. For this reason, Relationships implement Observer. Whenever a ClassModel changes location, the new location is passed to RelationshipEndPoints through the update() method in Relationship. The endpoints are then forced to update their coordinates to the new rectangle.  
Resizing class rectangles works in a similar way. Whenever the user mouses over the bottom-right corner of the class rectangle, the cursor is set to system default resize cursor and the element paint state is set to MOUSED\_OVER\_RESIZE. While this paint state is set, any dragging motion will result in the class rectangle being resized.  The rest of the process follows that of moving class rectangles, except instead of LocationEdits, SizeEdits are being created. 

\paragraph{\small{\tab Text labels outside any other element\\*}}

\hspace{-10pt}Adding explanatory text labels to a class diagram is a useful feature. It is implemented by simply creating a new TextLabelModel from the Manager (in much the same way as any other element). Please refer to the section on modifying textual elements . free labels adhere to this model. 

\paragraph{\small{\tab Controlling relationship arrows\\*}}

\hspace{-10pt} Relationship arrows only receive mouse events when the mouse is actually on the arrow, even though the actual component size is many times larger. This is done by overloading the contains(Point) method (for further details on this method, please refer to the javadoc). Whenever the user clicks on a point that is already present in the ArrayList of Points in the Relationship object, the Point can be moved around. If this point is an endpoint and therefore attached to a class rectangle, the overloaded move(int, int) method in RelationshipEndPoint ensures it stays there. If a user clicks and drags somewhere else, a new point is added to the line. The addPoint() method is called in Relationship. It checks all the existing segments and determines to which one the new point should belong. It then inserts the Point object into the ArrayList at the appropriate index. Removing a point is done by double-clicking on it. The RelationshipController simply calls removePoint() with the mouse event coordinates and the method determines whether a point should be removed, and if so, which one. Updating the view is done in the usual way.
Moving labels and cardinalities on Relationships works the same way as moving any other element. The only difference is that the movement is restricted . a Cardinality may never be further than a certain distance from its associated endpoint. Similarly, a RelationshipLabel cannot leave its Relationship. This constraint must be enforced not only for user actions but also for when relationships move as a result of something else moving. For this reason, Cardinalities and RelationshipLabels both have a fixed relative position to a reference point on the relationship arrow. When this reference point moves, realign() methods are called in the sub-elements and these reposition themselves. This way, a relationship cannot .run away. from its cardinalities.

\vspace{-5pt}\paragraph{\small{\tab Undo and redo functionality\\*}}

\hspace{-10pt} The undo functionality in the application is built atop the Java UndoManager framework. The Manager class extends UndoManager which, in turn, implements UndoableEditListener. DocumentElementModel has an addUndoableEditListener() method through which the Manager is assigned as a destination for UndoableEditEvents  to each and every element. Whenever a user-initiated action is acted upon, an UndoableEdit is created and sent to the fireUndoableEvent() method in DocumentElementModel. This method wraps the edit in an event and sends it to the Manager. From there on, undoing is defined by the Java API. Our undo package defines six types of UndoableEdits, all extending the AbstractUndoableEdit class. All of these store information about the previous state and the current state of the model object in question and override the undo() and redo() methods, toggling the states as needed. 

\emph{A note on existence.} As removed objects stick around in the program, it is relatively easy to bring them back into existence using the resurrect() method defined in DocumentElementModel. They can also be removed again, this time by using remove(). However, once cleanUp() is called on DocumentModel, they disappear from it. Trying to undo removes after that might still work but will create unpredictable behaviour when saving is thrown into the mix. When a document is exported into java code, it is cleaned up as we don.t want removed elements to appear in the actual code. This is why exporting disables all undos and redos on edits created before exporting was initiated. This is clearly a bug in the application, albeit forced, and we will be looking to fix it in the future. 

\emph{A note on relationship states.} Undoing actions on relationships works slightly differently than the other edits. In order to avoid having to create lots of edit classes for the many operations relationships allow to be performed on them, a whole relationship is simply cloned into a RelationshipStateEdit. When undoing, the current object simply copies all of its data from the cloned previous version.  

\vspace{-5pt}\paragraph{\small{\tab Resizing the canvas\\*}}

\hspace{-10pt} The Canvas is contained in a JPanel that has DiagramLayout set on it. This means that it will respect the canvas. preferred size no matter what it may be. It allows us to let the user resize the canvas to his liking. A canvas can either be snapped to the minimum size to contain all of its components through the fitToDiagram() method in the Manager or a resize dialog can be thrown up to let the user specify an exact size in pixels. This is implemented in the resizeCanvasDialog() function in the Manager and a separate ResizeDialog class.  The workings of this functionality are trivial. More information on it may be found in the javadoc. 


\vspace{-5pt}\paragraph{\small{\tab Changing the font\\*}}

\hspace{-10pt}When the user changes the font name or the font size on the toolbar, the changeFont() method is called in the Manager. This method simply sets the new font into DocumentPreferences and it is up to the Observers of DocumentPreferences to set their own font accordingly. Each top-level element has a clause in the update() method that lets them respond to changes in font. Also, top-level elements have to force their own font into their sub-elements by directly calling their setFont() method.

\vspace{-5pt}\paragraph{\small{\tab Changing the zoom\\*}}

\hspace{-10pt}This is a feature that was partially implemented at the very early stages of development. As the program grew, the support for the zoom feature throughout the program waned and it was decided that it would be completed later on. However, due to time constraints, this .later on. never materialized as implementing zoom got eclipsed by much more important features to implement and debug, such as undos. Completing the zoom may or may not be very difficult; however, there just wasn.t enough time to try it out. The zoom slider in the GUI is intentionally disabled and all methods relating to zoom are currently deprecated throughout the code. We are planning on fixing this in the future.
